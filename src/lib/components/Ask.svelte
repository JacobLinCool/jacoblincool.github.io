<script lang="ts">
	import { fly } from 'svelte/transition';
	import { marked } from 'marked';
	import TypingTexts from './TypingTexts.svelte';

	let {
		ask,
		starters,
		conversations = []
	}: {
		ask: (q: string) => Promise<void>;
		starters: string[];
		conversations?: {
			role: 'assistant' | 'user';
			text: string;
			image?: string;
		}[];
	} = $props();

	let question = $state('');
	let asking = $state(false);

	let input: HTMLInputElement;

	export async function _ask(q?: string) {
		if (asking) {
			return;
		}
		if (q) {
			question = q;
		}
		if (!question) {
			return;
		}
		asking = true;
		await ask(question);
		question = '';
		asking = false;
		scrollToBottom();

		setTimeout(() => {
			input?.focus();
		}, 0);
	}

	function handleKeyPress(event: KeyboardEvent) {
		if (event.key === 'Enter' && !event.isComposing) {
			_ask();
		}
	}

	// svelte-ignore non_reactive_update
	let chatContainer: HTMLDivElement;

	function scrollToBottom() {
		if (chatContainer) {
			chatContainer.scrollTo({
				top: chatContainer.scrollHeight,
				behavior: 'smooth'
			});
		}
	}

	function renderMarkdown(text: string) {
		const renderer = new marked.Renderer();
		const linkRenderer = renderer.link;
		renderer.link = (token) => {
			return linkRenderer
				.call(renderer, token)
				.replace(/^<a /, '<a target="_blank" rel="noopener noreferrer" ');
		};
		return marked(text, { renderer });
	}

	function isStreaming(conversation: any) {
		return (
			conversation.role === 'assistant' &&
			conversation === conversations[conversations.length - 1] &&
			asking
		);
	}
</script>

<div class="contents">
	{#if conversations.length > 0}
		<div
			class="no-scroll my-4 flex max-h-[min(50vh,600px)] flex-col overflow-y-auto"
			bind:this={chatContainer}
		>
			{#each conversations as conversation}
				<div
					class="mb-2 max-w-[90%] rounded-lg border border-gray-700 bg-gray-800 bg-opacity-50 p-2 {conversation.role ===
					'assistant'
						? 'self-start text-left'
						: 'self-end text-right'}"
				>
					<!-- <p class="font-bold">{conversation.role === 'assistant' ? name : 'You'}</p> -->
					<p class="prose prose-invert" class:animate-pulse={isStreaming(conversation)}>
						{#if conversation.text.length === 0}
							<span class="text-gray-400">
								.<TypingTexts texts={['....']} speedIn={1000} speedOut={100} gap={1000} />
							</span>
						{:else}
							{@html renderMarkdown(conversation.text)}
						{/if}
					</p>
					<!-- Render markdown content -->
					{#if conversation.image}
						<img src={conversation.image} alt="Response" class="mt-2 rounded-lg" />
					{/if}
				</div>
			{/each}
		</div>
	{/if}
	<input
		bind:this={input}
		bind:value={question}
		disabled={asking}
		type="text"
		placeholder="Ask me questions ..."
		onkeypress={handleKeyPress}
		class="w-full rounded-full border-2 border-gray-700 bg-transparent p-4 transition-all focus:border-blue-600 focus:outline-none"
		class:opacity-50={asking}
	/>
	{#if conversations.length === 0}
		<div class="mt-4" transition:fly={{ y: 20, duration: 300 }}>
			<div class="grid grid-cols-1 gap-2 text-sm md:grid-cols-2">
				{#each starters as starter}
					<button
						onclick={() => _ask(starter)}
						class="rounded-lg border border-gray-700 bg-transparent p-2 text-left">{starter}</button
					>
				{/each}
			</div>
		</div>
	{:else}
		<div
			class="no-scroll mt-4 overflow-x-auto whitespace-nowrap text-xs opacity-50"
			transition:fly={{ y: 20, duration: 300 }}
		>
			* All text, audio, and images are generated by fine-tuned / augmented models but may still
			include inaccurate informations.
		</div>
	{/if}
</div>
